#include "bsp_i2c_ee.h"
#include "bsp_usart.h"
#include "bsp_i2c_gpio.h"


/* 检测i2c总线设备，CPU向发送设备地址，然后读取设备应答来判断该设备是否存在 */
uint8_t ee_CheckDevice(uint8_t _Address)
{
	uint8_t ucAck;
	i2c_Start();
	
	/* 发送设备地址+读写控制bit */
	i2c_SendByte(_Address | EEPROM_I2C_WR);
	ucAck = i2c_WaitAck();       /* 检测设备的ACK应答 */
	
	i2c_Stop();                  /* 发送停止信号 */
	i2c_NAck();                  /*若输入的是读地址，需要产生非应答信号*/
	
	return ucAck;
}




/* 等待EEPROM到准备状态，在写入数据后，必须调用本函数 
	 写入操作时，使用I2C把数据传输到EEPROM后，
	 EEPROM会向内部空间写入数据需要一定的时间，
	 当EEPROM内部写入完成后会对I2C的设备寻址有响应，
	 调用本函数可等待至EEPROM内部时序写入完毕 */
uint8_t ee_WaitStandby(void)
{
	uint32_t wait_count= 0;
	
	while(ee_CheckDevice(EEPROM_DEV_ADDR))
	{
		//若检测超过次数，退出循环
		if(wait_count++> 0xFFFF)
		{
			return 1;
		}
		
	}
	return 0;
}


/* 从串行EEPROM指定地址处开始读取若干数据 _usAddress:起始地址 _usSize:数据长度，以字节为单位 _pReadBuff:存放读取到的数据的缓冲区指针 */
uint8_t ee_ReadBytes(uint8_t *_pReadBuff,uint16_t _usAddress,uint16_t _usSize)
{
	uint16_t i;
	
	/* 采用串行EEPROM随即读取指令序列，连续读取若干字节 */
	
	/* 第1步：发起I2C总线启动信号 */
	i2c_Start();
	
	/* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
	i2c_SendByte(EEPROM_DEV_ADDR | EEPROM_I2C_WR);       /* 此处是写指令 */
	
	/* 第3步：等待ACK */
	if(i2c_WaitAck() != 0)
	{
		goto cmd_fail;      /* EEPROM器件无应答 */
	}
	
	/* 第4步：发送字节地址，24C02只有256字节，因此1个字节就够了，如果是24C04以上，那么此处需要连发多个地址 */
	i2c_SendByte((uint8_t)_usAddress);
	
	/* 第5步：等待ACK */
	if(i2c_WaitAck()!=0)
	{
		goto cmd_fail;      /* EEPROM器件无应答 */
	}
	
	/* 第6步：重新启动I2C总线。前面的代码的目的向EEPROM传送地址，下面开始读取数据 */
	i2c_Start();
	
	
	/* 第7步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
	i2c_SendByte(EEPROM_DEV_ADDR | EEPROM_I2C_RD);      /* 此处是读指令 */
	
	/* 第8步：发送ACK */
	if(i2c_WaitAck() != 0)      /* EEPROM器件无应答 */
	{
		goto cmd_fail;       
	} 
	
	/* 第9步：循环读取数据 */
	for(i=0;i<_usSize;i++)
	{
		_pReadBuff[i] = i2c_ReadByte();     /* 读1个字节 */
		
		/* 每读完1个字节后，需要发送Ack， 最后一个字节不需要Ack，发Nack */
		if(i!= _usSize -1)
		{
			i2c_Ack();         /* 中间字节读完后，CPU产生ACK信号(驱动SDA = 0) */
		}
		else
		{
			i2c_NAck();        /* 最后1个字节读完后，CPU产生NACK信号(驱动SDA = 1) */
		}
	}
	/* 发送I2C总线停止信号 */
	i2c_Stop();
	
	return 1;
	
cmd_fail: /* 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备 */
	/* 发送I2C总线停止信号 */
	i2c_Stop();
	
	return 0;
}



/* 向串行EEPROM指定地址写入若干数据，采用页写入提高写入效率 _usAddress:起始地址 _usSize:写入数据长度 _pWriteBuff:存放读到的数据的缓冲区指针 */
uint8_t ee_WriteByte(uint8_t *_pWriteBuff,uint16_t _usAddress,uint16_t _usSize)
{
	uint16_t i,m;
	uint16_t usAddr;
	
	/* 
		写串行EEPROM不像读操作可以连续读取很多字节，每次写操作只能在同一个page。
		对于24xx02，page size = 8
		简单的处理方法为：按字节写操作模式，每写1个字节，都发送地址
		为了提高连续写的效率: 本函数采用page wirte操作。
	*/
	usAddr = _usAddress;
	for(i=0;i<_usSize;i++)
	{
		/* 当发送第1个字节或是页面首地址时，需要重新发起启动信号和地址 */
		if((i == 0) || (usAddr & (EEPROM_PAGE_SIZE - 1)) == 0)
		{
			/*　第０步：发停止信号，启动内部写操作　*/
			i2c_Stop();
			
			/* 通过检查器件应答的方式，判断内部写操作是否完成,一般小于 10ms 	
			
			  CLK频率为200KHz时，查询次数为30次左右	
			  原理同 ee_WaitStandby 函数，但该函数检查完成后会产生停止信号，不适用于此处				
			*/
			for(m=0;m<1000;m++)
			{
				/* 第1步：发起I2C总线启动信号 */
				i2c_Start();
				
				/* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
				i2c_SendByte(EEPROM_DEV_ADDR | EEPROM_I2C_WR);   /* 此处是写指令 */
				
				/* 第3步：发送一个时钟，判断器件是否正确应答 */
				if(i2c_WaitAck() == 0)
				{
					break;
				}
			}
			if(m == 1000)
			{
				goto cmd_fail;         /* EEPROM器件写超时 */
			}
			
			/* 第4步：发送字节地址，24C02只有256字节，因此1个字节就够了，如果是24C04以上，那么此处需要连发多个地址 */
			i2c_SendByte((uint8_t)usAddr);
			
			/* 第5步：等待ACK */
			if(i2c_WaitAck() != 0)
			{
				goto cmd_fail;       /* EEPROM器件无应答 */
			}
		}
		
		/* 第6步：开始写入数据 */
		i2c_SendByte(_pWriteBuff[i]);
		
		/* 第7步：发送ACK */
		if(i2c_WaitAck() != 0)
		{
			goto cmd_fail;  /* EEPROM器件无应答 */
		}
		usAddr++;    /* 地址增1 */		
	}
	
	/* 命令执行成功，发送I2C总线停止信号 */
	i2c_Stop();
	
	//等待最后一次EEPROM内部写入完成
	if(ee_WaitStandby() == 1)   //等于1表示超时
		goto cmd_fail;
	
	return 1;
	
cmd_fail:/* 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备 */
	/* 发送I2C总线停止信号 */
	i2c_Stop();
	return 0;
}



void ee_Erase(void)
{
	uint16_t i;
	uint8_t buff[EEPROM_SIZE];
	
	/* 填充缓冲区 */
	for(i=0;i<EEPROM_SIZE;i++)
	{
		buff[i] = 0xFF;
	}
	
	/* 写EEPROM, 起始地址 = 0，数据长度为 256 */
	if(ee_WriteByte(buff,0,EEPROM_SIZE) == 0)
	{
		printf("\r\n 擦除eeprom出错！ \r\n");
		return;
	}
	else
	{
		printf("擦除eeprom成功！\r\n");
	}
}


/* eeprom AT24C02 读写测试 */
uint8_t ee_Test(void)
{
	uint16_t i;
	uint8_t write_buff[EEPROM_SIZE];
	uint8_t read_buff[EEPROM_SIZE];
	
	if(ee_CheckDevice(EEPROM_DEV_ADDR) == 1)
	{
		/* 没有检测到EEPROM */
		printf("\r\n 没有检测到串行EEPROM \r\n");
		
		return 0;
	}
	
	
	/* 填充测试缓冲区 */
	for(i=0;i<EEPROM_SIZE;i++)
	{
		write_buff[i] = i;
	}
	
	if(ee_WriteByte(write_buff,0,EEPROM_SIZE) == 0)
	{
		printf("\r\n 写EEPROM出错 \r\n");
		return 0;
	}
	else
	{
		printf("\r\n 写EEPROM成功！ \r\n");
	}
	
	if(ee_ReadBytes(read_buff,0,EEPROM_SIZE) == 0)
	{
		printf("\r\n 读EERPOM出错！ \r\n");
		return 0;
	}
	else
	{
		printf("\r\n 读EEPROM成功，数据如下： \r\n");
	}
	
	for(i=0;i<EEPROM_SIZE;i++)
	{
		if(read_buff[i] != write_buff[i])
		{
			printf("\r\n 0x%02x \r\n",read_buff[i]);
			printf("\r\n 错误：EEPROM读出与写入的数据不一致 \r\n");
			return 0;
		}
		printf("\r\n %02x \r\n",read_buff[i]);
		
		if((i&15) == 15)
		{
			printf("\r\n");
		}
	}
	printf("\r\n eeprom读写测试成功！ \r\n");
	
	return 1;
}



